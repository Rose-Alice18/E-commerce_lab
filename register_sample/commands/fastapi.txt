# FastAPI Complete Development Guide

===========================================================================================
üì± Basic FastAPI Application
===========================================================================================

===========Minimal FastAPI App (main.py)===============

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def root():
    return {"message": "Hello World"}

# Run with: uvicorn main:app --reload
```

========Understanding the Components ===========
* `app = FastAPI()` - Creates the FastAPI instance
* `@app.get("/")` - Path operation decorator (route + HTTP method)
* `def root():` - Path operation function (handles request)
* `return {...}` - FastAPI automatically converts to JSON

========Server Configuration ===========

```python
# Development with auto-reload
uvicorn main:app --reload

# Custom host and port
uvicorn main:app --host 0.0.0.0 --port 9000 --reload

# In-code server start (for debugging)
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)
```

===========================================================================================
üõ£Ô∏è Path Parameters & Routing
===========================================================================================

===========Basic Path Parameters===============

```python
@app.get("/blog/{id}")
def show_blog(id: int):  # Automatic type validation
    return {"blog_id": id}

# URL: /blog/123 ‚Üí id = 123 (integer)
# URL: /blog/abc ‚Üí Automatic validation error
```

========Route Order is Critical ===========

```python
# ‚úÖ CORRECT ORDER - Specific routes BEFORE dynamic routes
@app.get("/blog/unpublished")  # Specific route first
def unpublished_blogs():
    return {"blogs": "unpublished"}

@app.get("/blog/{id}")         # Dynamic route after
def show_blog(id: int):
    return {"blog_id": id}

# ‚ùå WRONG ORDER - Dynamic route catches everything first
@app.get("/blog/{id}")         # This matches EVERYTHING
def show_blog(id: int): 
    pass

@app.get("/blog/unpublished")  # This will NEVER be reached
def unpublished(): 
    pass
```

========Multiple Path Parameters ===========

```python
@app.get("/blog/{id}/comments/{comment_id}")
def get_comment(id: int, comment_id: int):
    return {
        "blog_id": id,
        "comment_id": comment_id
    }
```

===========================================================================================
üîç Query Parameters & Validation
===========================================================================================

===========Basic Query Parameters===============

```python
@app.get("/blog")
def get_blogs(limit: int = 10, published: bool = True):
    return {
        "limit": limit,
        "published": published,
        "message": f"Fetching {limit} {'published' if published else 'all'} blogs"
    }

# URL: /blog?limit=5&published=false
```

========Optional Parameters & Advanced Types ===========

```python
from typing import Optional
from enum import Enum

class SortOrder(str, Enum):
    asc = "asc"
    desc = "desc"

@app.get("/blog")
def get_blogs(
    limit: int = 10,                    # Default value
    published: bool = True,             # Boolean validation
    sort: Optional[str] = None,         # Optional parameter
    sort_order: SortOrder = SortOrder.asc  # Enum validation
):
    return {
        "limit": limit,
        "published": published,
        "sort": sort,
        "sort_order": sort_order
    }
```

========Query Parameter Best Practices ===========
* ‚úÖ DO: Provide sensible defaults
* ‚úÖ DO: Use type hints for validation
* ‚úÖ DO: Use Optional[] for truly optional parameters
* ‚ùå DON'T: Make everything required - use defaults

===========================================================================================
üìù Request Body & Pydantic Models
===========================================================================================

===========Creating Pydantic Schemas (schemas.py)===============

```python
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class BlogCreate(BaseModel):
    title: str = Field(..., min_length=1, max_length=100, description="Blog title")
    body: str = Field(..., min_length=10, description="Blog content")
    published: Optional[bool] = False

class BlogResponse(BaseModel):
    id: int
    title: str
    body: str
    published: bool
    created_at: Optional[datetime] = None
    
    class Config:
        orm_mode = True  # Enables SQLAlchemy model serialization
        schema_extra = {
            "example": {
                "id": 1,
                "title": "My Awesome Blog Post",
                "body": "This is the content of my blog post...",
                "published": True
            }
        }
```

========Using Request Body in Routes ===========

```python
from schemas import BlogCreate, BlogResponse

@app.post("/blog", response_model=BlogResponse)
def create_blog(request: BlogCreate):
    return {
        "id": 1,
        "title": request.title,
        "body": request.body,
        "published": request.published,
        "created_at": datetime.now()
    }
```

========Combining Parameters ===========

```python
@app.put("/blog/{id}")
def update_blog(
    id: int,                    # Path parameter
    blog: BlogCreate,           # Request body
    notify_users: bool = False  # Query parameter
):
    return {
        "blog_id": id,
        "updated_data": blog.dict(),
        "notify_users": notify_users
    }

# URL: PUT /blog/123?notify_users=true
# Body: {"title": "Updated Title", "body": "Updated content"}
```

===========================================================================================
üóÑÔ∏è Database Integration (SQLAlchemy)
===========================================================================================

===========Database Setup (database.py)===============

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Database URLs for different databases
SQLALCHEMY_DATABASE_URL = "sqlite:///./blog.db"
# PostgreSQL: "postgresql://user:password@localhost/dbname"
# MySQL: "mysql+pymysql://user:password@localhost/dbname"

# Create engine
engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False}  # Only needed for SQLite
)

# Session factory
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

# Base class for ORM models
Base = declarative_base()

# Database dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

========ORM Models (models.py) ===========

```python
from sqlalchemy import Column, Integer, String, Boolean, Text, DateTime
from sqlalchemy.sql import func
from database import Base

class Blog(Base):
    __tablename__ = "blogs"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(100), nullable=False)
    body = Column(Text, nullable=False)
    published = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

# Create tables (run once)
# from database import engine
# Base.metadata.create_all(bind=engine)
```

========CREATE Operation ===========

```python
from fastapi import Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from database import get_db
import models, schemas

@app.post("/blog", response_model=schemas.BlogResponse, status_code=status.HTTP_201_CREATED)
def create_blog(request: schemas.BlogCreate, db: Session = Depends(get_db)):
    new_blog = models.Blog(**request.dict())
    db.add(new_blog)
    db.commit()
    db.refresh(new_blog)  # Get the created record with ID
    return new_blog
```

========READ Operations ===========

```python
# READ ALL with filtering
@app.get("/blog", response_model=List[schemas.BlogResponse])
def get_all_blogs(
    skip: int = 0,
    limit: int = 10,
    published: Optional[bool] = None,
    db: Session = Depends(get_db)
):
    query = db.query(models.Blog)
    
    if published is not None:
        query = query.filter(models.Blog.published == published)
    
    blogs = query.offset(skip).limit(limit).all()
    return blogs

# READ ONE
@app.get("/blog/{id}", response_model=schemas.BlogResponse)
def get_blog(id: int, db: Session = Depends(get_db)):
    blog = db.query(models.Blog).filter(models.Blog.id == id).first()
    if not blog:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Blog with id {id} not found"
        )
    return blog
```

========UPDATE Operation ===========

```python
@app.put("/blog/{id}", response_model=schemas.BlogResponse)
def update_blog(
    id: int,
    request: schemas.BlogCreate,
    db: Session = Depends(get_db)
):
    blog_query = db.query(models.Blog).filter(models.Blog.id == id)
    blog = blog_query.first()
    
    if not blog:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Blog with id {id} not found"
        )
    
    blog_query.update(request.dict(), synchronize_session=False)
    db.commit()
    return blog_query.first()
```

========DELETE Operation ===========

```python
@app.delete("/blog/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_blog(id: int, db: Session = Depends(get_db)):
    blog = db.query(models.Blog).filter(models.Blog.id == id).first()
    
    if not blog:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Blog with id {id} not found"
        )
    
    db.delete(blog)
    db.commit()
    return None
```

===========================================================================================
üîÑ HTTP Methods & CRUD Operations
===========================================================================================

===========HTTP Methods Mapping===============

```
GET    ‚Üí Read/Retrieve data        ‚Üí @app.get()      ‚Üí SELECT
POST   ‚Üí Create new resource       ‚Üí @app.post()     ‚Üí INSERT
PUT    ‚Üí Update entire resource    ‚Üí @app.put()      ‚Üí UPDATE
PATCH  ‚Üí Partial update           ‚Üí @app.patch()    ‚Üí UPDATE (partial)
DELETE ‚Üí Remove resource          ‚Üí @app.delete()   ‚Üí DELETE
```

========RESTful URL Patterns ===========

```python
GET    /blog          # Get all blogs
GET    /blog/{id}     # Get specific blog
POST   /blog          # Create new blog
PUT    /blog/{id}     # Update entire blog
PATCH  /blog/{id}     # Partially update blog
DELETE /blog/{id}     # Delete blog

# Nested resources
GET    /blog/{id}/comments        # Get blog comments
POST   /blog/{id}/comments        # Add comment to blog
DELETE /blog/{id}/comments/{c_id} # Delete specific comment
```

========Complete CRUD Template ===========

```python
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Optional

# CREATE
@app.post("/blog", response_model=schemas.BlogResponse, status_code=201, tags=["blogs"])
def create_blog(blog: schemas.BlogCreate, db: Session = Depends(get_db)):
    db_blog = models.Blog(**blog.dict())
    db.add(db_blog)
    db.commit()
    db.refresh(db_blog)
    return db_blog

# READ (List with filters)
@app.get("/blog", response_model=List[schemas.BlogResponse], tags=["blogs"])
def list_blogs(
    skip: int = 0,
    limit: int = 10,
    published: Optional[bool] = None,
    search: Optional[str] = None,
    db: Session = Depends(get_db)
):
    query = db.query(models.Blog)
    
    if published is not None:
        query = query.filter(models.Blog.published == published)
    
    if search:
        query = query.filter(models.Blog.title.contains(search))
    
    return query.offset(skip).limit(limit).all()

# READ (Single)
@app.get("/blog/{id}", response_model=schemas.BlogResponse, tags=["blogs"])
def get_blog(id: int, db: Session = Depends(get_db)):
    blog = db.query(models.Blog).filter(models.Blog.id == id).first()
    if not blog:
        raise HTTPException(status_code=404, detail="Blog not found")
    return blog

# UPDATE
@app.put("/blog/{id}", response_model=schemas.BlogResponse, tags=["blogs"])
def update_blog(id: int, blog: schemas.BlogCreate, db: Session = Depends(get_db)):
    db_blog = db.query(models.Blog).filter(models.Blog.id == id).first()
    if not db_blog:
        raise HTTPException(status_code=404, detail="Blog not found")
    
    for key, value in blog.dict().items():
        setattr(db_blog, key, value)
    
    db.commit()
    db.refresh(db_blog)
    return db_blog

# DELETE
@app.delete("/blog/{id}", status_code=204, tags=["blogs"])
def delete_blog(id: int, db: Session = Depends(get_db)):
    blog = db.query(models.Blog).filter(models.Blog.id == id).first()
    if not blog:
        raise HTTPException(status_code=404, detail="Blog not found")
    
    db.delete(blog)
    db.commit()
    return None
```

===========================================================================================
üì§ Response Models & Data Serialization
===========================================================================================

===========Controlling API Responses===============

```python
# Different response models for different use cases
class BlogSummary(BaseModel):
    id: int
    title: str
    published: bool

class BlogDetail(BaseModel):
    id: int
    title: str
    body: str
    published: bool
    created_at: datetime

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    # Notice: NO password field - hidden from response

# Use appropriate response model for each endpoint
@app.get("/blog", response_model=List[BlogSummary])
def list_blogs():
    pass  # Returns list of blog summaries

@app.get("/blog/{id}", response_model=BlogDetail)
def get_blog():
    pass  # Returns full blog details

@app.get("/users/{id}", response_model=UserResponse)
def get_user():
    pass  # Password field automatically excluded
```

========Response Status Codes ===========

```python
from fastapi import status

@app.post("/blog", status_code=status.HTTP_201_CREATED)
def create_blog():
    pass

@app.delete("/blog/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_blog():
    pass

@app.put("/blog/{id}", status_code=status.HTTP_200_OK)
def update_blog():
    pass
```

========Custom Response Models ===========

```python
class ApiResponse(BaseModel):
    success: bool
    message: str
    data: Optional[dict] = None

@app.post("/blog", response_model=ApiResponse)
def create_blog(blog: BlogCreate, db: Session = Depends(get_db)):
    # ... create logic
    return ApiResponse(
        success=True,
        message="Blog created successfully",
        data={"id": new_blog.id, "title": new_blog.title}
    )
```

===========================================================================================
üö® Exception Handling & Error Responses
===========================================================================================

===========Basic Exception Handling===============

```python
from fastapi import HTTPException, status

@app.get("/blog/{id}")
def get_blog(id: int, db: Session = Depends(get_db)):
    blog = db.query(models.Blog).filter(models.Blog.id == id).first()
    
    if not blog:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Blog with id {id} not found"
        )
    
    return blog
```

========Custom Exception Classes ===========

```python
from fastapi import Request
from fastapi.responses import JSONResponse

class BlogNotFoundException(Exception):
    def __init__(self, blog_id: int):
        self.blog_id = blog_id
        super().__init__(f"Blog with id {blog_id} not found")

@app.exception_handler(BlogNotFoundException)
async def blog_not_found_handler(request: Request, exc: BlogNotFoundException):
    return JSONResponse(
        status_code=404,
        content={
            "error": "Blog Not Found",
            "message": f"Blog with id {exc.blog_id} not found",
            "blog_id": exc.blog_id
        }
    )

# Usage in routes
@app.get("/blog/{id}")
def get_blog(id: int, db: Session = Depends(get_db)):
    blog = db.query(models.Blog).filter(models.Blog.id == id).first()
    if not blog:
        raise BlogNotFoundException(blog_id=id)
    return blog
```

========Common HTTP Status Codes Reference ===========

```
# Success codes
200  # OK - Successful GET, PUT
201  # Created - Successful POST
204  # No Content - Successful DELETE

# Client error codes  
400  # Bad Request - Invalid request data
401  # Unauthorized - Authentication required
403  # Forbidden - Insufficient permissions
404  # Not Found - Resource doesn't exist
422  # Unprocessable Entity - Validation failed

# Server error codes
500  # Internal Server Error - Server error
```

===========================================================================================
üìö API Documentation & Testing
===========================================================================================

===========Accessing Built-in Documentation===============

```bash
# Start server: uvicorn main:app --reload

# Documentation URLs:
# Swagger UI:    http://localhost:8000/docs
# ReDoc:         http://localhost:8000/redoc  
# OpenAPI JSON:  http://localhost:8000/openapi.json
```

========Enhanced Documentation with Tags & Descriptions ===========

```python
from fastapi import FastAPI

app = FastAPI(
    title="Blog API",
    description="A simple blog API built with FastAPI",
    version="1.0.0"
)

@app.get(
    "/blog", 
    tags=["blogs"], 
    summary="Get all blogs",
    description="Retrieve a list of all blogs with optional filtering and pagination"
)
def list_blogs(
    skip: int = 0,
    limit: int = 10,
    published: Optional[bool] = None
):
    """
    Retrieve a list of all blogs with optional filtering.
    
    Parameters:
    - **skip**: Number of blogs to skip (for pagination)
    - **limit**: Maximum number of blogs to return (max 100)
    - **published**: Filter by published status (true/false)
    
    Returns a list of blog objects.
    """
    return blogs
```

========Schema Documentation with Examples ===========

```python
from pydantic import Field

class BlogCreate(BaseModel):
    title: str = Field(
        ..., 
        min_length=1, 
        max_length=100, 
        description="Blog title",
        example="My Awesome Blog Post"
    )
    body: str = Field(
        ..., 
        min_length=10, 
        description="Blog content",
        example="This is the content of my blog post with detailed information..."
    )
    published: bool = Field(
        False, 
        description="Publication status",
        example=True
    )
    
    class Config:
        schema_extra = {
            "example": {
                "title": "Getting Started with FastAPI",
                "body": "FastAPI is a modern, fast web framework for building APIs with Python 3.6+",
                "published": true
            }
        }
```

========Manual Testing Methods ===========

```bash
# Testing with curl
curl -X GET "http://localhost:8000/blog?limit=5&published=true"

curl -X POST "http://localhost:8000/blog" \
     -H "Content-Type: application/json" \
     -d '{"title": "Test Blog", "body": "Test content", "published": true}'

curl -X PUT "http://localhost:8000/blog/1" \
     -H "Content-Type: application/json" \
     -d '{"title": "Updated Blog", "body": "Updated content", "published": false}'

curl -X DELETE "http://localhost:8000/blog/1"
```

===========================================================================================
üêõ Debugging & Development
===========================================================================================

===========VS Code Debugging Setup===============

```
1. Set breakpoints by clicking red dots in line numbers
2. Press Cmd+Shift+P (Mac) or Ctrl+Shift+P (Windows)  
3. Type "Debug" and select "Python: FastAPI"
4. Debugger starts and pauses at breakpoints
```

========Debug Configuration (.vscode/launch.json) ===========

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "FastAPI Debug",
            "type": "python",
            "request": "launch",
            "program": "-m",
            "args": ["uvicorn", "main:app", "--reload", "--port", "8000"],
            "console": "integratedTerminal",
            "justMyCode": false
        }
    ]
}
```

========Logging for Development & Production ===========

```python
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

@app.get("/blog/{id}")
def get_blog(id: int, db: Session = Depends(get_db)):
    logger.info(f"Fetching blog with id: {id}")
    
    blog = db.query(models.Blog).filter(models.Blog.id == id).first()
    
    if not blog:
        logger.warning(f"Blog with id {id} not found")
        raise HTTPException(status_code=404, detail="Blog not found")
    
    logger.info(f"Successfully retrieved blog: {blog.title}")
    return blog

# Add request logging middleware
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = datetime.now()
    response = await call_next(request)
    process_time = datetime.now() - start_time
    
    logger.info(
        f"{request.method} {request.url.path} - "
        f"Status: {response.status_code} - "
        f"Time: {process_time.total_seconds():.3f}s"
    )
    
    return response
```

========Environment-based Configuration ===========

```python
import os
from pydantic import BaseSettings

class Settings(BaseSettings):
    database_url: str = "sqlite:///./app.db"
    secret_key: str = "your-secret-key-here"
    debug: bool = True
    log_level: str = "INFO"
    
    class Config:
        env_file = ".env"

settings = Settings()

# Use in your app
if settings.debug:
    logger.setLevel(logging.DEBUG)
```

===========================================================================================
üöÄ Advanced Features
===========================================================================================

===========Dependency Injection Patterns===============

```python
from fastapi import Depends
from functools import lru_cache

# Database dependency (already covered)
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Settings dependency (cached)
@lru_cache()
def get_settings():
    return Settings()

# Authentication dependency
def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=401,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except PyJWTError:
        raise credentials_exception
    
    user = get_user(username=username)
    if user is None:
        raise credentials_exception
    return user

# Protected route
@app.get("/protected")
def protected_route(current_user: User = Depends(get_current_user)):
    return {"message": f"Hello {current_user.username}"}
```

========Background Tasks ===========

```python
from fastapi import BackgroundTasks
import smtplib
from email.mime.text import MIMEText

def send_email_notification(email: str, message: str):
    """Send email in background"""
    # Email sending logic here
    print(f"Sending email to {email}: {message}")

@app.post("/send-notification/")
def send_notification(
    email: str,
    message: str,
    background_tasks: BackgroundTasks
):
    background_tasks.add_task(send_email_notification, email, message)
    return {"message": "Notification will be sent in background"}
```

========File Upload Handling ===========

```python
from fastapi import File, UploadFile
import shutil
from pathlib import Path

@app.post("/upload-file/")
async def upload_file(file: UploadFile = File(...)):
    # Create uploads directory if it doesn't exist
    upload_dir = Path("uploads")
    upload_dir.mkdir(exist_ok=True)
    
    # Save file
    file_path = upload_dir / file.filename
    with file_path.open("wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    
    return {
        "filename": file.filename,
        "content_type": file.content_type,
        "size": file_path.stat().st_size
    }

@app.post("/upload-multiple-files/")
async def upload_multiple_files(files: List[UploadFile] = File(...)):
    uploaded_files = []
    for file in files:
        # Process each file
        uploaded_files.append({
            "filename": file.filename,
            "content_type": file.content_type
        })
    return {"uploaded_files": uploaded_files}
```

========CORS Configuration ===========

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",  # React development server
        "http://localhost:8080",  # Vue development server
        "https://yourdomain.com"  # Production frontend
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)
```

===========================================================================================
üèóÔ∏è Project Organization & Structure
===========================================================================================

===========Large Project Structure===============

```
project/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py              # FastAPI app instance
‚îÇ   ‚îú‚îÄ‚îÄ config.py            # Settings and configuration
‚îÇ   ‚îú‚îÄ‚îÄ database.py          # Database connection
‚îÇ   ‚îú‚îÄ‚îÄ dependencies.py      # Shared dependencies
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ models/              # SQLAlchemy models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ blog.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ schemas/             # Pydantic models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ blog.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ routers/             # API routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ blog.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/            # Business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ blog_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_service.py
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ utils/               # Utility functions
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ security.py
‚îÇ       ‚îî‚îÄ‚îÄ email.py
‚îÇ
‚îú‚îÄ‚îÄ tests/                   # Test files
‚îú‚îÄ‚îÄ alembic/                 # Database migrations
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ .env
‚îî‚îÄ‚îÄ Dockerfile
```

========Router Organization (routers/blog.py) ===========

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.database import get_db
from app.schemas.blog import BlogCreate, BlogResponse
from app.services.blog_service import BlogService

router = APIRouter(
    prefix="/blog",
    tags=["blogs"],
    responses={404: {"description": "Not found"}}
)

@router.get("/", response_model=List[BlogResponse])
def list_blogs(
    skip: int = 0,
    limit: int = 10,
    db: Session = Depends(get_db)
):
    service = BlogService(db)
    return service.get_blogs(skip=skip, limit=limit)

@router.post("/", response_model=BlogResponse, status_code=201)
def create_blog(blog: BlogCreate, db: Session = Depends(get_db)):
    service = BlogService(db)
    return service.create_blog(blog)

@router.get("/{id}", response_model=BlogResponse)
def get_blog(id: int, db: Session = Depends(get_db)):
    service = BlogService(db)
    blog = service.get_blog(id)
    if not blog:
        raise HTTPException(status_code=404, detail="Blog not found")
    return blog
```

========Main App with Routers (main.py) ===========

```python
from fastapi import FastAPI
from app.routers import blog, user, auth
from app.database import engine
from app.models import blog as blog_models

# Create database tables
blog_models.Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="Blog API",
    description="A comprehensive blog API",
    version="1.0.0"
)

# Include routers
app.include_router(blog.router)
app.include_router(user.router)
app.include_router(auth.router)
```

===========================================================================================
üìã Quick Reference Checklist
===========================================================================================

========Before Going to Production ===========
* ‚úÖ **Security:** Implement proper authentication and authorization
* ‚úÖ **Validation:** Add comprehensive input validation
* ‚úÖ **Error Handling:** Implement global exception handlers
* ‚úÖ **Logging:** Set up structured logging
* ‚úÖ **Testing:** Write unit and integration tests
* ‚úÖ **Environment:** Configure environment-specific settings
* ‚úÖ **Database:** Set up database migrations (Alembic)
* ‚úÖ **CORS:** Configure CORS for your frontend domains
* ‚úÖ **Rate Limiting:** Implement rate limiting for public endpoints
* ‚úÖ **Documentation:** Ensure comprehensive API documentation

========Common Commands ===========

```bash
# Install FastAPI and dependencies
pip install fastapi uvicorn sqlalchemy

# Run development server
uvicorn main:app --reload

# Run with custom settings
uvicorn main:app --host 0.0.0.0 --port 8080 --reload

# Generate requirements.txt